# Shared iOS Fastlane Configuration
# Usage: fastlane ios dev/prod

default_platform(:ios)

# Flavor-aware ENV lookup
# Checks {FLAVOR}_KEY first, falls back to KEY
# Example: FLAVOR=secil → checks SECIL_IOS_BUNDLE_ID, then IOS_BUNDLE_ID
def env_with_flavor(key)
  flavor = ENV['FLAVOR']
  if flavor && !flavor.empty?
    flavor_key = "#{flavor.upcase}_#{key}"
    return ENV[flavor_key] if ENV[flavor_key] && !ENV[flavor_key].empty?
  end
  ENV[key]
end

def get_changelog
  metadata_path = env_with_flavor('IOS_METADATA_PATH') || "metadata"
  changelog_file = File.join(metadata_path, "changelog.txt")

  if File.exist?(changelog_file) && !File.read(changelog_file).strip.empty?
    return File.read(changelog_file).strip
  else
    return "- Performance improvements."
  end
end

def find_latest_ipa
  ipa_pattern = File.join(@project_root, "build/ios/ipa/**/*.ipa")
  ipa_files = Dir.glob(ipa_pattern)
  return ipa_files.max_by { |f| File.mtime(f) }
end

# Find Flutter project root by walking up and looking for pubspec.yaml
def find_project_root
  dir = Dir.pwd
  while dir != '/'
    return dir if File.exist?(File.join(dir, 'pubspec.yaml'))
    dir = File.dirname(dir)
  end
  nil
end

platform :ios do

  before_all do |lane, options|
    skip_docs

    # Priority: 1) CI workspace 2) find pubspec.yaml
    @project_root = ENV["GITHUB_WORKSPACE"] ||        # GitHub Actions
                    ENV["CI_PROJECT_DIR"] ||          # GitLab
                    ENV["BUILD_SOURCESDIRECTORY"] ||  # Azure DevOps
                    find_project_root
    
    UI.user_error!("❌ Could not find Flutter project root!") unless @project_root
  end

  desc "Upload to TestFlight"
  lane :dev do
    
    ipa_file = find_latest_ipa
    unless ipa_file && File.exist?(ipa_file)
      UI.user_error!("❌ IPA file not found! Run build first.")
    end

    key_path = env_with_flavor('IOS_AUTH_KEY_PATH')
    key_content = env_with_flavor('IOS_AUTH_KEY_CONTENT')

    if key_path && File.exist?(key_path)
      app_store_connect_api_key(
        key_id: env_with_flavor("IOS_AUTH_KEY_ID"),
        issuer_id: env_with_flavor("IOS_ISSUER_ID"),
        key_filepath: key_path,
      )
    elsif key_content && !key_content.empty?
      app_store_connect_api_key(
        key_id: env_with_flavor("IOS_AUTH_KEY_ID"),
        issuer_id: env_with_flavor("IOS_ISSUER_ID"),
        key_content: key_content,
        is_key_content_base64: true,
      )
    else
      UI.user_error!("❌ Neither IOS_AUTH_KEY_PATH nor IOS_AUTH_KEY_CONTENT found!")
    end

    # Transporter - default enabled, set IOS_USE_TRANSPORTER=false to disable
    if env_with_flavor('IOS_USE_TRANSPORTER') != 'false'
      ENV["FASTLANE_ITUNES_TRANSPORTER_USE_SHELL_SCRIPT"] = "1"
      ENV["FASTLANE_ITUNES_TRANSPORTER_PATH"] = env_with_flavor('IOS_TRANSPORTER_PATH') || "/Applications/Transporter.app/Contents/itms"
    end

    upload_to_testflight(
      ipa: ipa_file,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Upload to App Store"
  lane :prod do

    ipa_file = find_latest_ipa

    unless ipa_file && File.exist?(ipa_file)
      UI.user_error!("❌ IPA file not found! Run build first.")
    end

    key_path = env_with_flavor('IOS_AUTH_KEY_PATH')
    key_content = env_with_flavor('IOS_AUTH_KEY_CONTENT')

    if key_path && File.exist?(key_path)
      app_store_connect_api_key(
        key_id: env_with_flavor("IOS_AUTH_KEY_ID"),
        issuer_id: env_with_flavor("IOS_ISSUER_ID"),
        key_filepath: key_path,
      )
    elsif key_content && !key_content.empty?
      app_store_connect_api_key(
        key_id: env_with_flavor("IOS_AUTH_KEY_ID"),
        issuer_id: env_with_flavor("IOS_ISSUER_ID"),
        key_content: key_content,
        is_key_content_base64: true,
      )
    else
      UI.user_error!("❌ Neither IOS_AUTH_KEY_PATH nor IOS_AUTH_KEY_CONTENT found!")
    end
    
    upload_to_app_store(
      ipa: ipa_file,
      release_notes: {
        'tr' => get_changelog,
      },
      skip_metadata: false,
      skip_screenshots: true,
      automatic_release: true,
      submit_for_review: true,
      precheck_include_in_app_purchases: false,
      force: true
    )
   
    # Crashlytics dSYM upload (optional)
    if env_with_flavor('IOS_GOOGLE_SERVICE_PLIST_PATH')
      begin
        dSYMsPath = File.join(@project_root, "build/ios/archive/Runner.xcarchive/dSYMs")
        upload_symbols_to_crashlytics(
          dsym_paths: Dir.children(dSYMsPath).map { |e| File.join(dSYMsPath, e) },
          gsp_path: env_with_flavor('IOS_GOOGLE_SERVICE_PLIST_PATH'),
        )
      rescue => e
        UI.error("Crashlytics upload failed: #{e.message}")
      end
    end
  end
end
